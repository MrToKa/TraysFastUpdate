@page "/trays/details/{Id:int}"

@using TraysFastUpdate.Models
@using TraysFastUpdate.Services
@using TraysFastUpdate.Services.Contracts
@using Excubo.Blazor.Canvas
@inject Microsoft.JSInterop.IJSRuntime js;

@inject ITrayService TrayService
@inject ICableService CableService
@inject ISnackbar Snackbar

<PageTitle>Details</PageTitle>

<MudText Typo="Typo.h5" Class="d-flex justify-center flex-grow-1 gap-4">Tray Details</MudText>

<MudItem Class="d-flex justify-center flex-grow-1 ma-2 pa-2">
    <MudButton Href="/trays"
    Rel="nofollow"
    Variant="Variant.Filled"
    Color="Color.Primary">
        Back to List
    </MudButton>
</MudItem>

<MudPaper Elevation="0" Class="pa-1 ma-1">
    <EditForm Model="@Tray" OnValidSubmit="HandleValidSubmit">
        <DataAnnotationsValidator />
        <MudGrid Class="d-flex justify-center flex-grow-1 gap-4 pa-1 ma-1">
            <MudItem xs="12" sm="7" Class="pa-1 ma-1" Style="@($"background: #BDBDBD;")">
                <MudText Typo="Typo.h6" Class="d-flex justify-center flex-grow-1 gap-4">Tray general information</MudText>
                <MudCard>
                    <MudCardContent>
                        <MudTextField @bind-Value="Tray.Name" For="@(() => Tray.Name)" Label="Tray Name" ReadOnly="true" />
                        <MudTextField @bind-Value="Tray.Type" For="@(() => Tray.Type)" Label="Tray Type" ReadOnly="false" />
                        <MudTextField @bind-Value="Tray.Purpose" For="@(() => Tray.Purpose)" Label="Tray Purpose" ReadOnly="false" />
                        <MudNumericField @bind-Value="Tray.Width" For="@(() => Tray.Width)" Label="Tray Width [mm]" ReadOnly="false" />
                        <MudNumericField @bind-Value="Tray.Height" For="@(() => Tray.Height)" Label="Tray Height [mm]" ReadOnly="false" />
                        <MudNumericField @bind-Value="Tray.Length" For="@(() => Tray.Length)" Label="Tray Length [mm]" ReadOnly="false" />
                        <MudNumericField @bind-Value="Tray.Weight" For="@(() => Tray.Weight)" Label="Tray Weight [kg/m]" ReadOnly="false" />
                    </MudCardContent>
                    <MudCardActions>
                        <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="Color.Primary">Save changes</MudButton>
                    </MudCardActions>
                </MudCard>
            </MudItem>
        </MudGrid>
    </EditForm>
</MudPaper>

<MudPaper Elevation="0" Class="pa-1 ma-1" Style="@($"background: #BDBDBD;")">
    <MudText Typo="Typo.h6" Class="d-flex justify-center flex-grow-1 gap-4">Cables on tray</MudText>
    @if (CablesOnTray == null || CablesOnTray.Count == 0)
    {
        <MudAlert Severity="Severity.Info">No cables found.</MudAlert>
    }
    else
    {
        <MudDataGrid T="Cable" Items="@CablesOnTray" ReadOnly="true"
        Bordered="true" Dense="true" ColumnResizeMode="ResizeMode.Column">
            <Columns>
                <TemplateColumn Title="No." CellClass="d-flex justify-center" Sortable="false" Filterable="false" Editable="false">
                    <CellTemplate>
                        @(CablesOnTray.IndexOf(context.Item) + 1)
                    </CellTemplate>
                </TemplateColumn>
                <PropertyColumn Property="x => x.Tag" Title="Cable Tag" Hideable="false" />
                <PropertyColumn Property="x => x.CableType.Type" Title="Cable Type" Hideable="false" />
                <PropertyColumn Property="x => x.CableType.Diameter" Title="Cable Diameter [mm]" Hideable="false" />
                <PropertyColumn Property="x => x.CableType.Weight" Title="Cable Weight [kg/m]" Hideable="false" />
            </Columns>
            <PagerContent>
                <MudDataGridPager PageSizeOptions="[15, 25, 50]" T="Cable" />
            </PagerContent>
        </MudDataGrid>
    }
</MudPaper>

<MudPaper>
    <MudGrid Class="d-flex justify-center flex-grow-1 gap-4 pa-1 ma-1">
        <MudItem xs="12" sm="7" Class="pa-1 ma-1" Style="@($"background: #BDBDBD;")">
            <MudText Typo="Typo.h6" Class="d-flex justify-center flex-grow-1 gap-4">Tray Weight Calculations</MudText>
            <MudCard>
                <MudCardContent>
                    <MudTextField @bind-Value="Tray.ResultSupportsCount" For="@(() => Tray.ResultSupportsCount)" Label="Supports count" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultSupportsTotalWeight" For="@(() => Tray.ResultSupportsTotalWeight)" Label="Total Supports Weight [kg]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultSupportsWeightLoadPerMeter" For="@(() => Tray.ResultSupportsWeightLoadPerMeter)" Label="Supports weight load per meter [kg/m]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultTrayWeightLoadPerMeter" For="@(() => Tray.ResultTrayWeightLoadPerMeter)" Label="Tray weight load per meter [kg/m]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultTrayOwnWeightLoad" For="@(() => Tray.ResultTrayOwnWeightLoad)" Label="Tray total own weight [kg]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultCablesWeightPerMeter" For="@(() => Tray.ResultCablesWeightPerMeter)" AutoGrow Label="Cables weight load per meter [kg/m]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultCablesWeightLoad" For="@(() => Tray.ResultCablesWeightLoad)" Label="Cables total weight on the tray [kg]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultTotalWeightLoadPerMeter" For="@(() => Tray.ResultTotalWeightLoadPerMeter)" Label="Total tray weight load per meter [kg/m]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultTotalWeightLoad" For="@(() => Tray.ResultTotalWeightLoad)" Label="Total tray weight [kg]" ReadOnly="true" />
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>
</MudPaper>

<MudPaper>
    <MudGrid Class="d-flex justify-center flex-grow-1 gap-4 pa-1 ma-1">
        <MudItem xs="12" sm="7" Class="pa-1 ma-1" Style="@($"background: #BDBDBD;")">
            <MudText Typo="Typo.h6" Class="d-flex justify-center flex-grow-1 gap-4">Tray Space Calculations</MudText>
            <MudCard>
                <MudCardContent>
                    <MudTextField @bind-Value="Tray.ResultSpaceOccupied" For="@(() => Tray.ResultSpaceOccupied)" AutoGrow Label="Space occupied by cables [mm]" ReadOnly="true" />
                    <MudTextField @bind-Value="Tray.ResultSpaceAvailable" For="@(() => Tray.ResultSpaceAvailable)" Label="Cable tray free space [%]" ReadOnly="true" />
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>
</MudPaper>

<MudPaper>
    <MudItem Class="pa-1 ma-1">
        <Canvas @ref="canvas" width="@CanvasWidth" height="@CanvasHeight" style="border: 1px solid black" />
    </MudItem>
</MudPaper>

@code {
    [Parameter]
    public int Id { get; set; }

    private Tray Tray { get; set; } = new Tray();

    private List<Cable> CablesOnTray = new List<Cable>();
    private List<Cable> BottomRowPowerCables = new List<Cable>();
    private List<Cable> BottomRowControlCables = new List<Cable>();

    private Dictionary<string, Dictionary<string, List<Cable>>> CableBundles = new Dictionary<string, Dictionary<string, List<Cable>>>();

    private Canvas canvas = new Canvas();

    private int canvasScale = 3;

    private double CanvasWidth => ((Tray.Width) * canvasScale) + 100;
    private double CanvasHeight => ((Tray.Height) * canvasScale) + 100;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await DrawTray();
        }
    }

    private async Task HandleTrayPropertyChange()
    {
        await InvokeAsync(StateHasChanged);
        await DrawTray();
    }

    protected override async Task OnInitializedAsync()
    {
        Tray = await TrayService.GetTrayAsync(Id);
        await TrayService.UpdateTrayAsync(Tray);
        CablesOnTray = await CableService.GetCablesOnTrayAsync(Tray);
        CableBundles = await CableService.GetCablesBundlesOnTrayAsync(Tray);
    }

    private async Task HandleValidSubmit()
    {
        try
        {
            await TrayService.UpdateTrayAsync(Tray);
            Snackbar.Add("Tray details updated successfully!", Severity.Success);
            await HandleTrayPropertyChange();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error updating tray details: {ex.Message}", Severity.Error);
        }
    }

    private async Task DrawTray()
    {
        try
        {
            await using (var ctx = await canvas.GetContext2DAsync())
            {
                const int textPadding = 20;
                const int CProfileHeight = 15;

                await ctx.RestoreAsync();
                await ctx.TranslateAsync(-textPadding, -(50 + Tray.Height * canvasScale / 2));
                await ctx.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

                // Add title text above the rectangle
                await ctx.SetTransformAsync(1, 0, 0, 1, 0, 0);

                await ctx.SaveAsync();
                await ctx.FontAsync("24px Arial");
                await ctx.FillStyleAsync("black");
                await ctx.TextAlignAsync(TextAlign.Center);
                await ctx.TextBaseLineAsync(TextBaseLine.Middle);
                await ctx.FillTextAsync($"Cables bundles laying concept for tray {Tray.Name}", Tray.Width * canvasScale / 2, 30);
                await ctx.RestoreAsync();

                //Height at the left side
                await ctx.SaveAsync();
                await ctx.FontAsync("24px Arial");
                await ctx.FillStyleAsync("black");
                await ctx.TextAlignAsync(TextAlign.Center);
                await ctx.TextBaseLineAsync(TextBaseLine.Middle);
                await ctx.TranslateAsync(textPadding, 50 + Tray.Height * canvasScale / 2);
                await ctx.RotateAsync(Math.PI / 2);
                await ctx.FillTextAsync($"Useful tray height: {Tray.Height - CProfileHeight} mm", 0, 0);
                await ctx.RestoreAsync();

                // Draw rectangle
                await ctx.StrokeStyleAsync("black");
                await ctx.StrokeRectAsync(50, 50, Tray.Width * canvasScale, (Tray.Height - CProfileHeight) * canvasScale);
                //Draw C-profile
                await ctx.StrokeStyleAsync("black");
                await ctx.StrokeRectAsync(50, 50 + (Tray.Height - CProfileHeight) * canvasScale, Tray.Width * canvasScale, CProfileHeight * canvasScale);
                //fill C-profile
                await ctx.FillStyleAsync("#D3D3D3");
                await ctx.FillRectAsync(50, 50 + (Tray.Height - CProfileHeight) * canvasScale, Tray.Width * canvasScale, CProfileHeight * canvasScale);

                // Width at the bottom
                await ctx.FontAsync("24px Arial");
                await ctx.FillStyleAsync("black");
                await ctx.TextAlignAsync(TextAlign.Center);
                await ctx.TextBaseLineAsync(TextBaseLine.Middle);
                await ctx.FillTextAsync($"Useful tray width: {(Tray.Width)} mm", (Tray.Width * canvasScale) / 2, 50 + (Tray.Height * canvasScale) + textPadding);

                await ctx.SetTransformAsync(1, 0, 0, 1, 0, 0);
                double spacing = 1 * canvasScale; // Adjust spacing as needed

                double leftStartX = 50 + spacing;
                double rightStartX = 50 + Tray.Width * canvasScale - spacing;
                double bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;

                var bundles = CableBundles;

                foreach (var bundle in bundles)
                {
                    if (bundle.Key == "Power")
                    {
                        var sortedBundles = bundle.Value.OrderByDescending(x => x.Value[0].CableType.Diameter).ToList();

                        foreach (var sortedBundle in sortedBundles)
                        {
                            (int rows, int columns) = calculateRowsAndColumns(Tray.Height - CProfileHeight, 1, sortedBundle.Value, "Power");

                            int row = 0;
                            int column = 0;

                            var sortedCables = sortedBundle.Value.OrderByDescending(x => x.CableType.Diameter).ToList();

                            if (sortedBundle.Key == "42.1-60")
                            {
                                foreach (var cable in sortedCables)
                                {
                                    int cableIndex = sortedCables.IndexOf(cable);
                                    if (cableIndex != 0 && cableIndex % 2 == 0)
                                    {
                                        bottomStartY -= ((cable.CableType.Diameter * canvasScale) / 2) * (Math.Sqrt(3) / 2) + ((cable.CableType.Diameter * canvasScale) / 2) - spacing * 2;
                                        leftStartX = 50 + spacing + BottomRowPowerCables.Sum(x => x.CableType.Diameter + 1) * canvasScale - (cable.CableType.Diameter * canvasScale + spacing) * 1.5;
                                        row = 1;
                                    }
                                    double radius = cable.CableType.Diameter / 2 * canvasScale;
                                    await ctx.BeginPathAsync();
                                    await ctx.ArcAsync(leftStartX + radius, bottomStartY - radius, radius, 0, Math.PI * 2);
                                    await ctx.ClosePathAsync();
                                    await ctx.StrokeAsync();
                                    // Draw cable number inside the circle
                                    await ctx.FontAsync("12px Arial");
                                    await ctx.FillStyleAsync("black");
                                    await ctx.TextAlignAsync(TextAlign.Center);
                                    await ctx.TextBaseLineAsync(TextBaseLine.Middle);
                                    int cableNumber = CablesOnTray.IndexOf(cable) + 1;
                                    await ctx.FillTextAsync(cableNumber.ToString(), leftStartX + radius, bottomStartY - radius);
                                    bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;

                                    if (row == 0)
                                    {
                                        BottomRowPowerCables.Add(cable);
                                        leftStartX = 50 + spacing + BottomRowPowerCables.Sum(x => x.CableType.Diameter + 1) * canvasScale;
                                    }

                                    if (row == 1)
                                    {
                                        row = 0;
                                        leftStartX = 50 + spacing + BottomRowPowerCables.Sum(x => x.CableType.Diameter + 1) * canvasScale;
                                        bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;
                                    }
                                }

                            }
                            else
                            {
                                foreach (var cable in sortedCables)
                                {
                                    double radius = cable.CableType.Diameter / 2 * canvasScale;
                                    await ctx.BeginPathAsync();
                                    await ctx.ArcAsync(leftStartX + radius, bottomStartY - radius, radius, 0, Math.PI * 2);
                                    await ctx.ClosePathAsync();
                                    await ctx.StrokeAsync();
                                    // Draw cable number inside the circle
                                    await ctx.FontAsync("12px Arial");
                                    await ctx.FillStyleAsync("black");
                                    await ctx.TextAlignAsync(TextAlign.Center);
                                    await ctx.TextBaseLineAsync(TextBaseLine.Middle);
                                    int cableNumber = CablesOnTray.IndexOf(cable) + 1;
                                    await ctx.FillTextAsync(cableNumber.ToString(), leftStartX + radius, bottomStartY - radius);
                                    bottomStartY -= cable.CableType.Diameter * canvasScale + spacing;

                                    if (row == 0)
                                    {
                                        BottomRowPowerCables.Add(cable);
                                    }

                                    row++;
                                    if (row == rows)
                                    {
                                        row = 0;
                                        column++;
                                        leftStartX = 50 + spacing + BottomRowPowerCables.Sum(x => x.CableType.Diameter + 1) * canvasScale;
                                        bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;
                                    }
                                }
                            }

                            leftStartX = 50 + spacing + BottomRowPowerCables.Sum(x => x.CableType.Diameter + 1) * canvasScale;
                            bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;
                        }
                    }

                    else if (bundle.Key == "Control")
                    {
                        var sortedBundles = bundle.Value.OrderByDescending(x => x.Value[0].CableType.Diameter).ToList();

                        foreach (var sortedBundle in sortedBundles)
                        {
                            (int rows, int columns) = calculateRowsAndColumns(Tray.Height - CProfileHeight, 1, sortedBundle.Value, "Control");

                            int row = 0;

                            var sortedCables = sortedBundle.Value.OrderByDescending(x => x.CableType.Diameter).ToList();

                            foreach (var cable in sortedCables)
                            {
                                double radius = cable.CableType.Diameter / 2 * canvasScale;
                                await ctx.BeginPathAsync();
                                await ctx.ArcAsync(rightStartX - radius, bottomStartY - radius, radius, 0, Math.PI * 2);
                                await ctx.ClosePathAsync();
                                await ctx.StrokeAsync();
                                // Draw cable number inside the circle
                                await ctx.FontAsync("12px Arial");
                                await ctx.FillStyleAsync("black");
                                await ctx.TextAlignAsync(TextAlign.Center);
                                await ctx.TextBaseLineAsync(TextBaseLine.Middle);
                                int cableNumber = CablesOnTray.IndexOf(cable) + 1;
                                await ctx.FillTextAsync(cableNumber.ToString(), rightStartX - radius, bottomStartY - radius);
                                bottomStartY -= cable.CableType.Diameter * canvasScale + spacing;

                                if (row == 0)
                                {
                                    BottomRowControlCables.Add(cable);
                                }

                                row++;
                                if (row == rows)
                                {
                                    row = 0;
                                    rightStartX = 50 + Tray.Width * canvasScale - spacing - BottomRowControlCables.Sum(x => x.CableType.Diameter + 1) * canvasScale;
                                    bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;
                                }
                            }
                            rightStartX = 50 + Tray.Width * canvasScale - spacing - BottomRowControlCables.Sum(x => x.CableType.Diameter + 1) * canvasScale;
                            bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;
                        }
                    }
                    else if (bundle.Key == "MV")
                    {
                        var sortedBundles = bundle.Value.OrderByDescending(x => x.Value[0].CableType.Diameter).ToList();

                        foreach (var sortedBundle in sortedBundles)
                        {
                            (int rows, int columns) = calculateRowsAndColumns(Tray.Height - CProfileHeight, 1, sortedBundle.Value, "Power");

                            int row = 0;
                            int cableIndex = 2;
                            double leftStartBottom = 0;
                            double leftStartTop = 0;

                            var sortedCables = sortedBundle.Value.OrderByDescending(x => x.CableType.Diameter).ToList();

                            leftStartX = 50 + spacing + sortedCables.ElementAt(0).CableType.Diameter;

                            leftStartBottom = leftStartX;
                            leftStartTop = leftStartX + (sortedCables.ElementAt(0).CableType.Diameter / 2 + 0.5) * canvasScale;

                            foreach (var cable in sortedCables)
                            {
                                if (cableIndex == sortedCables.IndexOf(cable))
                                {
                                    bottomStartY -= ((cable.CableType.Diameter * canvasScale) / 2) * (Math.Sqrt(3) / 2) + ((cable.CableType.Diameter * canvasScale) / 2) - spacing * 2;
                                    leftStartX = leftStartTop;
                                    row = 1;
                                    cableIndex += 3;
                                }
                                double radius = cable.CableType.Diameter / 2 * canvasScale;
                                await ctx.BeginPathAsync();
                                await ctx.ArcAsync(leftStartX + radius, bottomStartY - radius, radius, 0, Math.PI * 2);
                                await ctx.ClosePathAsync();
                                await ctx.StrokeAsync();
                                // Draw cable number inside the circle
                                await ctx.FontAsync("12px Arial");
                                await ctx.FillStyleAsync("black");
                                await ctx.TextAlignAsync(TextAlign.Center);
                                await ctx.TextBaseLineAsync(TextBaseLine.Middle);
                                int cableNumber = CablesOnTray.IndexOf(cable) + 1;
                                await ctx.FillTextAsync(cableNumber.ToString(), leftStartX + radius, bottomStartY - radius);
                                bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;

                                if (row == 0)
                                {
                                    BottomRowPowerCables.Add(cable);
                                    leftStartX += (cable.CableType.Diameter + 1) * canvasScale;
                                    leftStartBottom = leftStartX;
                                }

                                if (row == 1)
                                {
                                    row = 0;
                                    leftStartBottom += (cable.CableType.Diameter + 1) * canvasScale * 2;
                                    leftStartX = leftStartBottom;
                                    leftStartTop += (cable.CableType.Diameter + 1) * canvasScale * 4;
                                    bottomStartY = 50 + (Tray.Height - CProfileHeight) * canvasScale - spacing;
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during canvas drawing: {ex.Message}");
        }
    }

    private (int, int) calculateRowsAndColumns(double trayHeight, int spacing, List<Cable> bundle, string purpose)
    {
        int rows = 0;
        int columns = 0;
        double diameter = bundle.Max(x => x.CableType.Diameter);

        if (purpose == "Power")
        {
            rows = Math.Min((int)Math.Floor((trayHeight - spacing) / (diameter + spacing)), 3);
            columns = (int)Math.Floor((double)bundle.Count / rows);
        }
        else if (purpose == "Control")
        {
            rows = Math.Min((int)Math.Floor((trayHeight - spacing) / (diameter + spacing)), 7);
            columns = Math.Min((int)Math.Ceiling((double)bundle.Count / rows), 20);
        }

        if (rows > columns)
        {
            rows = (int)Math.Floor(Math.Ceiling(Math.Sqrt(bundle.Count)));
            columns = (int)Math.Floor(Math.Ceiling(Math.Sqrt(bundle.Count)));
        }

        return (rows, columns);
    }
}
